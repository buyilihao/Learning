#                                       （一）**JVM内存空间图解**

 ![20160917225930028](.\20160917225930028.png)

## jvm运行时各数据区解释：

`程序计数器：`线程私有。是一块较小的内存，是当前线程所执行的字节码的行号指示器。是Java虚拟机规范中唯一没有规定OOM（OutOfMemoryError）的区域。

`Java栈：`线程私有。生命周期和线程相同。是Java方法执行的内存模型。执行每个方法都会创建一个栈帧，用于存储局部变量和操作数（对象引用）。局部变量所需要的内存空间大小在编译期间完成分配。所以栈帧的大小不会改变。存在两种异常情况：若线程请求深度大于栈的深度，抛StackOverflowError。若栈在动态扩展时无法请求足够内存，抛OOM。

`Java堆：`所有线程共享。虚拟机启动时创建。存放对象实例  和数组。所占内存最大。分为新生代（Young区），老年代（Old区）。新生代分Eden区，Servior区。Servior区又分为From space区和To Space区。Eden区和Servior区的内存比为8:1。 当扩展内存大于可用内存，抛OOM。

`方法区：`所有线程共享。用于存储已被虚拟机加载的类信息、常量、静态变量等数据。又称为非堆（Non – Heap）。方法区又称“永久代”。GC很少在这个区域进行，但不代表不会回收。这个区域回收目标主要是针对常量池的回收和对类型的卸载。当内存申请大于实际可用内存，抛OOM。

`本地方法栈：`线程私有。与Java栈类似，但是不是为Java方法（字节码）服务，而是为本地非Java方法服务。也会抛StackOverflowError和OOM。

##  栈区详解：

栈的特点
也叫栈内存，是java虚拟机的内存模型之一，每当启动一个新线程时，Java虚拟机都会为它分配一个Java栈。虚拟机只会直接对Java栈执行两种操作，以帧为单位的压栈和出栈。

栈存储的是什么 
方法内的局部变量表、操作数栈、动态链接、方法出口信息、其他等信息
栈的生命周期 
是在线程创建时创建，线程结束而消亡，释放内存，由此可见栈内存是私有的。 
栈内存是以栈帧(Stack Frame)为单位存储，栈帧是一个内存区块，是一个有关方法(Method)和运行期数据的数据集。 

### 方法栈详解：

本地方法栈与虚拟机栈发挥的功能非常类似，只是虚拟机栈为虚拟机执行java方法而服务，而**本地方法栈为虚拟机执行native方法**而服务。 有的虚拟机把本地方法栈和虚拟机栈合二为一，比如**Sun HotSpot 虚拟机。** 

##### 本地方法：

- JAVA方法是由JAVA编写的，编译成字节码，存储在class文件中
- 本地方法是由其它语言编写的，编译成和处理器相关的机器代码
- 简单地讲，一个Native Method就是一个java调用非java代码的接口。一个Native Method是这样一个java的方法：该方法的实现由非java语言实现，比如C。 

  什么是本地方法：https://blog.csdn.net/asdasdasd123123123/article/details/81910116

`对于一个运行中的java程序而言，可能会用到跟本地方法相关的数据区域。当一个线程调用本地方法时，它就进入一个全新的不受虚拟机限制的全新世界。本地方法也可以通过本地方法接口调用虚拟机的运行时数据区域。` 

`任何本地方法接口都会使用某种本地方法栈。当虚拟机调用java方法时，虚拟机会创建一个栈帧并且压入虚拟机栈；当虚拟机调用本地（native）方法时，虚拟机不会创建新的栈帧，虚拟机栈会保持不变，虚拟机只是简单的动态连接并直接调用相关的本地方法。`

下图描绘的场景是：一个线程调用本地方法，本地方法又需要调用java方法的情况。 

![20170817104119100](.\20170817104119100.png) 

`该线程首先调用了两个java方法，然后第二个java方法调用了本地方法。假设这是一个c栈，第一个c函数有调用了第二个c函数，第二个函数又调用了一个java方法，进入java栈，然后这个java方法又调用一个java方法，即当前栈帧对应的方法，当前方法。`当一个方法M1被调用时就产生了一个栈帧S1，并被压入到栈中，M1方法又调用了M2方法，于是产生栈帧S2也被压入栈，M2方法执行完毕后，S2栈帧先出栈，S1栈帧再出栈，遵循“先进后出”原则。![20180420210637643](.\20180420210637643.jpg)


## 栈帧
![20180420211726491](.\20180420211726491.jpg)

### 栈帧内部结构：

1.局部变量表 
保存函数的参数以及局部变量用的，局部变量表中的变量只在当前函数调用中有效，当函数调用结束后，随着函数栈帧的销毁，局部变量表也会随之销毁。 
存放基本数据类型变量(boolean、byte、char、short、int、float)、引用类型的变量(reference)、returnAddress(指向一条字节码指令的地址)类型的变量。

2.操作数栈 
主要用于保存计算过程的中间结果，同时作为计算过程中变量临时的存储空间。只支持出栈入栈操作。在概念模型中，两个栈帧是相互独立的。但是大多数虚拟机的实现都会进行优化，令两个栈帧出现一部分重叠。令下面的部分操作数栈与上面的局部变量表重叠在一块，这样在方法调用的时候可以共用一部分数据，无需进行额外的参数复制传递。

3.动态链接 
每个栈帧都包含一个指向运行时常量池中该栈帧所属性方法的引用，持有这个引用是为了支持方法调用过程中的动态连接。在Class文件的常量池中存有大量的 符号引用，字节码中的方法调用指令就以常量池中指向方法的符号引用为参数。这些符号引用一部分会在类加载阶段或第一次使用的时候转化为直接引用，这种转化 称为静态解析。另外一部分将在每一次的运行期期间转化为直接引用，这部分称为动态连接。

4.方法出口信息 
在方法退出之前，都需要返回到方法被调用的位置，程序才能继续执行，方法返回时可能需要在栈帧中保存一些信息，用来帮助恢复它的上 层方法的执行状态。一般来说，方法正常退出时，调用者PC计数器的值就可以作为返回地址，栈帧中很可能会保存这个计数器值。而方法异常退出时，返回地址是 要通过异常处理器来确定的，栈帧中一般不会保存这部分信息

5.其他

##### 符号引用和直接引用：

-    `Java类从加载到虚拟机内存中开始，到卸载出内存为止，它的整个生命周期包括，加载 ,验证 , 准备 , 解析 , 初始化 	 , 卸载 ，总共七个阶段。其中验证 ,准备 , 解析 统称为连接。`
-    `而在解析阶段会有一个步将常量池当中二进制数据当中的符号引用转化为直接引用的过程。`
- `符号引用 ：符号引用以一组符号来描述所引用的目标。符号引用可以是任何形式的字面量，只要使用时能无歧义地定位到目标即可，符号引用和虚拟机的布局无关。个人理解为：在编译的时候一个每个java类都会被编译成一个class文件，但在编译的时候虚拟机并不知道所引用类的地址，多以就用符号引用来代替，而在这个解析阶段就是为了把这个符号引用转化成为真正的地址的阶段。`
- `直接引用 ：直接引用和虚拟机的布局是相关的，不同的虚拟机对于相同的符号引用所翻译出来的直接引用一般是不同的。如果有了直接引用，那么直接引用的目标一定被加载到了内存中。` 

## 名词解释

##### StackOverflowError：栈溢出错误

##### OutOfMemoryError：内存溢出错误

- **1、stackoverflow：**

  每当java程序启动一个新的线程时，java虚拟机会为他分配一个栈，java栈以帧为单位保持线程运行状态；当线程调用一个方法是，jvm压入一个新的栈帧到这个线程的栈中，只要这个方法没执行结束，这个栈帧就存在。 如果方法的嵌套调用层次太多(如递归调用),随着java栈中的帧的增多，最终导致这个线程的栈中的所有栈帧的大小的总和大于-Xss设置的值，而产生StackOverflowError溢出异常。

  如果一个线程在计算时所需要用到栈大小 > 配置允许最大的栈大小，那么Java虚拟机将抛StackOverflowError 

- **2、outofmemory：**

- 2.1、栈内存溢出

  java程序启动一个新线程时，没有足够的空间为改线程分配java栈，一个线程java栈的大小由-Xss设置决定；JVM则抛出OutOfMemoryError异常。

- 2.2、堆内存溢出

  java堆用于存放对象的实例，当需要为对象的实例分配内存时，而堆的占用已经达到了设置的最大值(通过-Xmx)设置最大值，则抛出OutOfMemoryError异常。

- 2.3、方法区内存溢出

  方法区用于存放java类的相关信息，如类名、访问修饰符、常量池、字段描述、方法描述等。在类加载器加载class文件到内存中的时候，JVM会提取其中的类信息，并将这些类信息放到方法区中。 
  当需要存储这些类信息，而方法区的内存占用又已经达到最大值（通过-XX:MaxPermSize）；将会抛出OutOfMemoryError异常对于这种情况的测试，基本的思路是运行时产生大量的类去填满方法区，直到溢出。这里需要借助CGLib直接操作字节码运行时，生成了大量的动态类。

![2018-11-05_170033](.\2018-11-05_170033.png)



![2018-11-05_170210](.\2018-11-05_170210.png)

程序详解：

1、执行main函数会创建一个线程，同时创建一个虚拟机栈（栈内存）

2、调用statck.method()时，会对method()进行压栈操作，将method()运行期数据的数据集(批注1)保存到栈帧1(Stack Frame)(如果main方法里面调用多个方法，会执行多个压栈操作)。

3、method()递归调用时，都会产生一个新的栈帧区块，这时就会连续的产生新的栈帧区块

4、当栈内存超过系统配置的栈内存-Xss:2048(批注2)，就会出现java.lang.StackOverflowError异常。这也是为什么对于需要谨慎使用递归调用的原因！



批注1：基本数据类型变量、引用类型的变量、returnAddress类型的变量、操作数栈、动态链接、方法出口等 

批注2：-Xss 为jvm启动的每个线程分配的内存大小 

![2018-11-05_170509](.\2018-11-05_170509.png)

List是动态增长的，因此容量不够了，就会扩容，一旦空闲内存分配完毕，请求不到其他内存，就抛出OutOfMemoryError。 



# （二）垃圾回收机制：

主要参考：http://www.cnblogs.com/dolphin0520/p/3783345.html

GC，即垃圾回收机制，目前主流的JVM(HotSpot)采用的是分代收集算法，与C++不同的是，Java采用的是类似于树形结构的**可达性分析法（跟踪算法）**来判断对象是否还存在引用。即：从gcroot开始，把所有可以搜索得到的对象标记为存活对象。 

`目前java 中可作为GC Root 的对象有`

`1，虚拟机栈中引用的对象（本地变量表）`

`2，方法区中静态属性引用的对象`

`3，方法区中常量引用的对象`

`4，本地方法栈中引用的对象（Native Object）`

要准确理解Java的垃圾回收机制，就要从：“什么时候”，“对什么东西”，“做了什么”三个方面来具体分析 

第一：“什么时候”即就是GC触发的条件。GC触发的条件有两种。

（1）程序调用System.gc时可以触发；（2）系统自身来决定GC触发的时机。 

1，对象没有引用

2，作用域发生未捕获异常

3，程序在作用域正常执行完毕

4，程序执行了System.exit（）

5，程序发生意外终止（被杀进程等）

 `System.gc()方法建议 JVM 执行垃圾收集以使得可被释放的内存能立即被使用，当此方法返回的时候， JVM 已经做了最大的努力从被丢弃的对象上回收内存空间。程序员不能指定收集哪些内存，一般而言也不用关心这个问题，除非是程序的内存消耗很大，特别是有很多临时对象时可以“建议“进行垃圾收集以提高可用内存。需要指出的是调用 System.gc()方法不能保证 JVM 立即进行垃圾收集，而只能是建议,因为垃圾收集线程的优先级很低（通常是最低的）。`

系统判断GC触发的依据：根据Eden区和From Space区的内存大小来决定。当内存大小不足时，则会启动GC线程并停止应用线程 。

第二：“对什么东西”笼统的认为是Java对象并没有错。但是准确来讲，GC操作的对象分为：通过可达性分析法无法搜索到的对象和可以搜索到的对象。对于搜索不到的方法进行标记。 

第三：“做了什么”最浅显的理解为释放对象。但是从GC的底层机制可以看出，对于可以搜索到的对象进行复制操作，对于搜索不到的对象，调用finalize()方法进行释放。 

`具体过程：当GC线程启动时，会通过可达性分析法把Eden区和From Space区的存活对象复制到To Space区，然后把Eden Space和From Space区的对象释放掉。当GC轮训扫描To Space区一定次数后，把依然存活的对象复制到老年代，然后释放To Space区的对象。`

对于用可达性分析法搜索不到的对象，GC并不一定会回收该对象。要完全回收一个对象，至少需要经过两次标记的过程。

第一次标记：对于一个没有其他引用的对象，筛选该对象是否有必要执行finalize()方法，如果没有执行必要，则意味可直接回收。（筛选依据：是否复写或执行过finalize()方法；因为finalize方法只能被执行一次）。

第二次标记：如果被筛选判定位有必要执行，则会放入FQueue队列，并自动创建一个低优先级的finalize线程来执行释放操作。如果在一个对象释放前被其他对象引用，则该对象会被移除FQueue队列。

## 一.如何确定某个对象是“垃圾”？

### 引用计数器算法：

`在java中是通过引用来和对象进行关联的，也就是说如果要操作对象，必须通过引用来进行。那么很显然一个简单的办法就是通过引用计数来判断一个对象是否可以被回收。不失一般性，如果一个对象没有任何引用与之关联，则说明该对象基本不太可能在其他地方被使用到，那么这个对象就成为可被回收的对象了。这种方式成为引用计数法。这种方式的特点是实现简单，而且效率较高，但是它无法解决循环引用的问题，两个引用互相引用对方，导致它们的引用计数都不为0，那么垃圾收集器就永远不会回收它们。`

### 可达性分析法（根搜索算法/跟踪算法）：

 `为了解决这个问题，在Java中采取了 可达性分析法。该方法的基本思想是通过一系列的“GC Roots”对象作为起点进行搜索，如果在“GC Roots”和一个对象之间没有可达路径，则称该对象是不可达的，不过要注意的是被判定为不可达的对象不一定就会成为可回收对象。被判定为不可达的对象要成为可回收对象必须至少经历两次标记过程，如果在这两次标记过程中仍然没有逃脱成为可回收对象的可能性，则基本上就真的成为可回收对象了。`

总结一下平常遇到的比较常见的将对象判定为可回收对象的情况： 

1）显示地将某个引用赋值为null或者将已经指向某个对象的引用指向新的对象，比如下面的代码： 

```java
Object obj = new Object();
obj = null;
Object obj1 = new Object();
Object obj2 = new Object();
obj1 = obj2;
```

　2）局部引用所指向的对象，比如下面这段代码： 

```java
void fun() {
 
.....
    for(int i=0;i<10;i++) {
        Object obj = new Object();
        System.out.println(obj.getClass());
    }   
}
```

3）只有弱引用与其关联的对象，比如： 

```java
	WeakReference<String> wr = new WeakReference<String>(new String("world"));
```

## 二.典型的垃圾收集算法

- Java虚拟机规范并没有对如何实现垃圾收集器做出明确的规定，因此各个厂商的虚拟机可以采用不同的方式来实现垃圾收集器，所以在此只讨论几种常见的垃圾收集算法的核心思想。 

### 1.Mark-Sweep（标记-清除）算法 

`这是最基础的垃圾回收算法，之所以说它是最基础的是因为它最容易实现，思想也是最简单的。标记-清除算法分为两个阶段：标记阶段和清除阶段。标记阶段的任务是标记出所有需要被回收的对象，清除阶段就是回收被标记的对象所占用的空间。具体过程如下图所示：` ![181024382398115](.\181024382398115.jpg)

　`从图中可以很容易看出标记-清除算法实现起来比较容易，但是有一个比较严重的问题就是容易产生内存碎片，碎片太多可能会导致后续过程中需要为大对象分配空间时无法找到足够的空间而提前触发新的一次垃圾收集动作。` 

### 2.Copying（复制）算法 

- 为了解决Mark-Sweep算法的缺陷，Copying算法就被提了出来。它将可用内存按容量划分为大小相等的两块，每次只使用其中的一块。当这一块的内存用完了，就将还存活着的对象复制到另外一块上面，然后再把已使用的内存空间一次清理掉，这样一来就不容易出现内存碎片的问题。具体过程如下图所示： ![181041528488728](.\181041528488728.jpg)

- 这种算法虽然实现简单，运行高效且不容易产生内存碎片，但是却对内存空间的使用做出了高昂的代价，因为能够使用的内存缩减到原来的一半。

- 很显然，Copying算法的效率跟存活对象的数目多少有很大的关系，如果存活对象很多，那么Copying算法的效率将会大大降低。

### 3.Mark-Compact（标记-整理）算法 

标记整理算法采用标记-清除算法一样的方式进行对象的标记，但在清除时不同，在回收未存活的对象占用的空间后，会将所有的存活对象往一端的空闲空间移动，并更新对应的指针。标记-整理算法是在标记-清除算法的基础上，又进行了对象的移动，因此成本更高，但是却解决了内存碎片的问题。

![20161012144612809](.\20161012144612809.jpg)

### 4.Generational Collection（分代收集）算法

　　分代收集算法是目前大部分JVM的垃圾收集器采用的算法。它的核心思想是根据对象存活的生命周期将内存划分为若干个不同的区域。一般情况下将堆区划分为老年代（Tenured Generation）和新生代（Young Generation），`老年代的特点是每次垃圾收集时只有少量对象需要被回收，而新生代的特点是每次垃圾回收时都有大量的对象需要被回收，`那么就可以根据不同代的特点采取最适合的收集算法。

　　目前大部分垃圾收集器对于新生代都采取复制算法，因为新生代中每次垃圾回收都要回收大部分对象，也就是说需要复制的操作次数较少，但是实际中并不是按照1：1的比例来划分新生代的空间的，一般来说是将新生代划分为一块较大的Eden空间和两块较小的Survivor空间，每次使用Eden空间和其中的一块Survivor空间，当进行回收时，将Eden和Survivor中还存活的对象复制到另一块Survivor空间中，然后清理掉Eden和刚才使用过的Survivor空间。

　　而由于老年代的特点是每次回收都只回收少量对象，一般使用的是标记整理算法。

　　注意，在堆区之外还有一个代就是永久代（Permanet Generation），它用来存储class类、常量、方法描述等。对永久代的回收主要回收两部分内容：废弃常量和无用的类。

## 三.典型的垃圾收集器

参考：https://blog.csdn.net/sunny243788557/article/details/52797088?utm_source=blogxgwz1

　　垃圾收集算法是 内存回收的理论基础，而垃圾收集器就是内存回收的具体实现。下面介绍一下HotSpot（JDK 7)虚拟机提供的几种垃圾收集器，用户可以根据自己的需求组合出各个年代使用的收集器。

　　1.Serial/Serial Old

　　Serial/Serial Old收集器是最基本最古老的收集器，它是一个单线程收集器，属于串行收集器 ，并且在它进行垃圾收集时，必须暂停所有用户线程。Serial收集器是针对新生代的收集器，采用的是Copying算法，Serial Old收集器是针对老年代的收集器，采用的是Mark-Compact算法。它的优点是实现简单高效，但是缺点是会给用户带来停顿。

串行回收方式适合低端机器，是Client模式下的默认收集器，对CPU和内存的消耗不高，适合用户交互比较少，后台任务较多的系统。 

　　2.ParNew

　   ParNew收集器是Serial收集器的多线程版本，使用多个线程进行垃圾收集。 同样有Stop The World的问	 题，他是多CPU模式下的首选回收器（该回收器在单CPU的环境下回收效率远远低于Serial收集器，所以一定要注意场景哦），也是Server模式下的默认收集器。

　　3.Parallel Scavenge

　　Parallel Scavenge收集器是一个新生代的多线程收集器（并行收集器），它在回收期间不需要暂停其他用户线程，其采用的是Copying算法，该收集器与前两个收集器有所不同，它主要是为了达到一个可控的吞吐量。

吞吐量=程序运行时间/(JVM执行回收的时间+程序运行时间) 。

`在当今网络告诉发达的今天，良好的响应速度是提升用户体验的一个重要指标，多核并行云计算的发展要求程序尽可能的使用CPU和内存资源，尽快的计算出最终结果，因此在交互不多的云端，比较适合使用该回收器。` 

　　4.Parallel Old

　ParallelOld是老生代并行收集器的一种，使用标记整理算法、是老生代吞吐量优先的一个收集器。这个收集器是JDK1.6之后刚引入的一款收集器，我们看之前那个图之间的关联关系可以看到，早期没有ParallelOld之前，吞吐量优先的收集器老生代只能使用串行回收收集器，大大的拖累了吞吐量优先的性能，自从JDK1.6之后，才能真正做到较高效率的吞吐量优先。 

　　5.CMS

　　CMS（Current Mark Sweep）收集器是一种以获取最短回收停顿时间为目标的收集器，CMS又称响应时间优先(最短回收停顿)的回收器，使用并发模式回收垃圾，使用标记-清除算法，CMS对CPU是非常敏感的，它的回收线程数=（CPU+3）/4，因此当CPU是2核的实惠，回收线程将占用的CPU资源的50%，而当CPU核心数为4时仅占用25%。 

CMS 为了确保能够扫描到所有的对象，避免在InitialMarking 中还有未标识到的对象，采用的方法为找到标记了的对象，并将这些对象放入Stack 中，扫描时寻找此对象依赖的对象，如果依赖的对象的地址在其之前，则将此对象进行标记，并同时放入Stack 中，如依赖的对象地址在其之后，则仅标记该对象。 

在进行ConcurrentMarking 时minor GC 也可能会同时进行，这个时候很容易造成旧生代对象引用关系改变，CMS 为了应对这样的并发现象，提供了一个Mod UnionTable 来进行记录，在这个Mod Union Table中记录每次minor GC 后修改了的Card 的信息。这也是ParallelScavenge不能和CMS一起使用的原因。 

　　6.G1

　　G1收集器是当今收集器技术发展最前沿的成果，它是一款面向服务端应用的收集器，它能充分利用多CPU、多核环境。因此它是一款并行与并发收集器，并且它能建立可预测的停顿时间模型。

他是商用高性能垃圾回收器，通过重新划分内存区域，整合优化CMS，同时注重吞吐量和响应时间，但是杯具的是被oracle收购之后这个收集器属于商用收费收集器，因此目前基本上没有人使用 。

`这些垃圾回收器又分为串行回收方式、并行回收方式合并发回收方式执行，分别运用于不同的场景。` 

![20161012144950445](.\20161012144950445.jpg)

## 四.堆空间内存分配： ![181512325519249](.\181512325519249.jpg)

1.对象的内存分配，往大方向上讲就是在堆上分配，对象主要分配在新生代的Eden Space和From Space，少数情况下会直接分配在老年代。如果新生代的Eden Space和From Space的空间不足，则会发起一次GC，如果进行了GC之后，Eden Space和From Space能够容纳该对象就放在Eden Space和From Space。在GC的过程中，会将Eden Space和From  Space中的存活对象移动到To Space，然后将Eden Space和From Space进行清理。如果在清理的过程中，To Space无法足够来存储某个对象，就会将该对象移动到老年代中。在进行了GC之后，使用的便是Eden space和To Space了，下次GC时会将存活对象复制到From Space，如此反复循环。当对象在Survivor区躲过一次GC的话，其对象年龄便会加1，默认情况下，如果对象年龄达到15岁，就会移动到老年代中。

![20161012144920132](.\20161012144920132.jpg)

　　一般来说，大对象会被直接分配到老年代，所谓的大对象是指需要大量连续存储空间的对象，最常见的一种大对象就是大数组，比如：

　　byte[] data = new byte[4*1024*1024]

　　这种一般会直接在老年代分配存储空间。

　　当然分配的规则并不是百分之百固定的，这要取决于当前使用的是哪种垃圾收集器组合和JVM的相关参数。

2    大对象直接进入老生代

3、    年长者(长期存活对象)进入老生代

4、    群体效应(大批中年对象进入老生代)

5、    担保GC(担保minorGC)

###  **Minor GC ，Full GC 触发条件** 

Minor GC触发条件：当Eden区满时，触发Minor GC。

Full GC触发条件：

（1）调用System.gc时，系统建议执行Full GC，但是不必然执行

（2）老年代空间不足

（3）方法去空间不足

（4）通过Minor GC后进入老年代的平均大小大于老年代的可用内存

（5）由Eden区、From Space区向To Space区复制时，对象大小大于To Space可用内存，则把该对象转存到老年代，且老年代的可用内存小于该对象大小

# （三）   引用的分类

### 1，强引用

只要引用存在，垃圾回收器永远不会回收

Objectobj = new Object（）;

// 可直接通过物镜取得对应的对象如obj.equels（NEWOBJECT（））; 

而这样 obj对象对后面newObject的一个强引用，只有当obj这个引用被释放之后，对象才会被释放掉，这也是我们经常所用到的编码形式。

### 2、  软引用

非必须引用，内存溢出之前进行回收，可以通过以下代码实现

Objectobj = new Object();

SoftReference<Object>sf = new SoftReference<Object>(obj);

obj =null;

sf.get();//有时候会返回null

这时候sf是对obj的一个软引用，通过sf.get()方法可以取到这个对象，当然，当这个对象被标记为需要回收的对象时，则返回null；
软引用主要用户实现类似缓存的功能，在内存足够的情况下直接通过软引用取值，无需从繁忙的真实来源查询数据，提升速度；当内存不足时，自动删除这部分缓存数据，从真正的来源查询这些数据。

### 3、  弱引用

第二次垃圾回收时回收，可以通过如下代码实现

Objectobj = new Object();

WeakReference<Object>wf = new WeakReference<Object>(obj);

obj =null;

wf.get();//有时候会返回null

wf.isEnQueued();//返回是否被垃圾回收器标记为即将回收的垃圾

弱引用是在第二次垃圾回收时回收，短时间内通过弱引用取对应的数据，可以取到，当执行过第二次垃圾回收时，将返回null。

弱引用主要用于监控对象是否已经被垃圾回收器标记为即将回收的垃圾，可以通过弱引用的isEnQueued方法返回对象是否被垃圾回收器

### 4、  虚引用（幽灵/幻影引用）

​           垃圾回收时回收，无法通过引用取到对象值，可以通过如下代码实现

Objectobj = new Object();

PhantomReference<Object>pf = new PhantomReference<Object>(obj);

obj=null;

pf.get();//永远返回null

pf.isEnQueued();//返回从内存中已经删除

虚引用是每次垃圾回收的时候都会被回收，通过虚引用的get方法永远获取到的数据为null，因此也被成为幽灵引用。

虚引用主要用于检测对象是否已经从内存中删除。

## 2.     方法区也是会被回收的

！但是方法区的回收条件非常苛刻，只有同时满足以下三个条件才会被回收！

1、所有实例被回收

2、加载该类的ClassLoader被回收

3、Class对象无法通过任何途径访问(包括反射)