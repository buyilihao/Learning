## 概论

上一篇文章我们分析了矩阵类动态规划，说到这类动态规划通常在一个矩阵中进行，我们只需要考虑当前位置的信息即可，分析并定义状态的时候，也只需要分析当前位置和其相邻位置的关系，通常这样做就可以达到拆解问题的目的。

这次再来看一类动态规划问题，**序列类动态规划问题**，这类动态规划问题较为普遍，分析难度相比之前也略有提升，通常问题的输入参数会涉及数组或是字符串。

在开始之前，先解释一下子数组（子串）和子序列的区别，你可以看看下面这个例子：

```basic
输入数组：[1,2,3,4,5,6,7,8,9]
子数组：[2,3,4], [5,6,7], [6,7,8,9], ...
子序列：[1,5,9], [2,3,6], [1,8,9], [7,8,9], ...
```

可以看到的是，**子数组必须是数组中的一个连续的区间，而子序列并没有这样一个要求**。

你只需要保证子序列中的元素的顺序和原数组中元素的顺序一致即可，例如，在原数组中，元素 1 出现在元素 9 之前，那么在子序列中，如果这两个元素同时出现，那么 1 也必须在 9 之前。

为什么要说这个？

不知道你有没有发现，这里的子数组的问题和我们前面提到的矩阵类动态规划的分析思路很类似，只需要考虑当前位置，以及当前位置和相邻位置的关系。

通过这样的分析就可以把之前讲的内容和今天要介绍的内容关联起来了，相比矩阵类动态规划，序列类动态规划最大的不同在于，**对于第 i 个位置的状态分析，它不仅仅需要考虑当前位置的状态，还需要考虑前面 i – 1 个位置的状态**，这样的分析思路其实可以从子序列的性质中得出。

对于这类问题的问题拆解，有时并不是那么好发现问题与子问题之间的联系，但是通常来说思考的方向其实在于 **寻找当前状态和之前所有状态的关系**，我们通过几个非常经典的动态规划问题来一起看看。

## 题目分析

### 最长上升子序列

#### 题目描述

给定一个无序的整数数组，找到其中最长上升子序列的长度。

**示例:**

```basic
[10,9,2,5,3,7,101,18]

子序列 [2,3,7,18] 的起始位置是 2，终止位置是 18
子序列 [5,7,101] 的起始位置是 5，终止位置是 101
```

**说明:**

- 可能会有多种最长上升子序列的组合，你只需要输出对应的长度即可。
- 你算法的时间复杂度应该为 O(n^2^) 。

**进阶:** 你能将算法的时间复杂度降低到 O(n log n) 吗?

#### 题目解析

给定一个数组，求最长递增子序列。**因为是子序列，这样对于每个位置的元素其实都存在两种可能，就是选和不选**，如果我们用暴力的解法，枚举出所有的子序列，然后判断他们是不是递增的，选取最大的递增序列，这样做的话，时间复杂度是 O(2^n)，显然不高效。

那这里我们就需要思考用动态规划进行优化，我们按之前的四个步骤来具体分析一下：

- 问题拆解

  我们要求解的问题是 “数组中最长递增子序列”，一个子序列虽然不是连续的区间，但是它依然有起点和终点，比如：

  ```basic
  [10,9,2,5,3,7,101,18]
  
  子序列 [2,3,7,18] 的起始位置是 2，终止位置是 18
  子序列 [5,7,101] 的起始位置是 5，终止位置是 101
  ```

  如果我们确定终点位置，然后去 **看前面 i – 1 个位置中，哪一个位置可以和当前位置拼接在一起**，这样就可以把第 i 个问题拆解成思考之前 i – 1 个问题，注意这里我们并不是不考虑起始位置，在遍历的过程中我们其实已经考虑过了。

- 状态定义

  问题拆解中我们提到 “第 i 个问题和前 i – 1 个问题有关”，也就是说 “如果我们要求解第 i 个问题的解，那么我们必须考虑前 i – 1 个问题的解”，我们定义 **dp[i] 表示以位置 i 结尾的子序列的最大长度**，也就是说 dp[i] 里面记录的答案保证了该答案表示的子序列以位置 i 结尾。

- 递推方程

  对于 i 这个位置，我们需要考虑前 i – 1 个位置，看看哪些位置可以拼在 i 位置之前，如果有多个位置可以拼在 i 之前，那么必须选最长的那个，这样一分析，递推方程就有了：

  ```basic
  dp[i] = Math.max(dp[j],...,dp[k]) + 1, 
  其中 inputArray[j] < inputArray[i], inputArray[k] < inputArray[i]
  ```

- 实现

  在实现这里，我们需要考虑状态数组的初始化，因为对于每个位置，它本身其实就是一个序列，因此所有位置的状态都可以初始化为 1。

最后提一下，对于这道题来说，这种方法其实不是最优的，但是在这里的话就不展开讲了，理解序列类动态规划的解题思路是关键。

#### 参考代码

```java
//@五分钟学算法//www.cxyxiaowu.compublic 
int lengthOfLIS(int[] nums) {
    if (nums == null || nums.length == 0) {
        return 0;
    }

    // dp[i] -> the longest length sequence from 0 - i, and must include nums[i]
    int[] dp = new int[nums.length];

    Arrays.fill(dp, 1);

    int max = 0;

    for (int i = 0; i < nums.length; ++i) {
        for (int j = 0; j < i; ++j) {
            if (nums[i] > nums[j]) {
                dp[i] = Math.max(dp[j] + 1, dp[i]);
            }
        }

        max = Math.max(max, dp[i]);
    }

    return max;
}
```

